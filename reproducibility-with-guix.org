#+TITLE: Computational reproducibility with Guix

* Dependencies: what it takes to run a program
Let's start with a simple (and rather uninteresting) C program:
#+begin_src c :tangle pi.c :eval no
#include <math.h>
#include <stdio.h>

int main()
{
    printf( "M_PI: %.10lf\n", M_PI);
    printf( "4 * atan(1.): %.10lf\n", 4.*atan(1.));
    printf( "Leibniz' formula (four terms): %.10lf\n", 4.*(1.-1./3.+1./5.-1./7.));
    return 0;
}
#+end_src

What does it take to actually run this program? A C compiler, obviously. Let's create an environment containing nothing but a C compiler. The option =--container= ensures the best possible isolation from the standard environment that your system installation and user account provide for day-to-day work. This environment really contains nothing but a C compiler, and has access to no other files than those in the current directory.

#+begin_src sh :session C-compiler :results output :exports both
guix environment --container --ad-hoc gcc-toolchain
#+end_src

#+RESULTS:

Now I can compile and run my little program:
#+begin_src sh :session C-compiler :results output :exports both
gcc pi.c -o pi
./pi
#+end_src

#+RESULTS:
: 
: pi = 3.1415926536
: 4 * atan(1.): 3.1415926536
: Leibniz' formula (four terms): 2.8952380952

It works! So now I can be sure that my program has a single dependency: the Guix package =gcc-toolchain=. The "toolchain" part suggests that it contains a bit more than just the compiler. Let's look at it in more detail:

#+begin_src sh :results output :exports both
guix show gcc-toolchain
#+end_src

#+RESULTS:
#+begin_example
name: gcc-toolchain
version: 9.2.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@9.2.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 8.3.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@8.3.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 7.4.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@7.4.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 6.5.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@6.5.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 5.5.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@5.5.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 4.9.4
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@4.9.4 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 4.8.5
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@4.8.5 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

#+end_example

Guix actually knows about several versions of this toolchain. We didn't ask for a specific one, so what we got is the first one in this list, which is the one with the highest version number. Let's check:
#+begin_src sh :session C-compiler :results output :exports both
gcc --version
#+end_src

#+RESULTS:
: gcc (GCC) 9.2.0
: Copyright (C) 2019 Free Software Foundation, Inc.
: This is free software; see the source for copying conditions.  There is NO
: warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

The dependency list of =gcc-toolchain@9.2.0= is among the informtion provided by =guix show= (see output above):
#+begin_example
binutils@2.32 gcc@9.2.0 glibc@2.29 ld-wrapper@0
#+end_example

Now we can feed these dependencies to =guix show=, one by one, in order to learn more about them:
#+begin_src sh :results output :exports both
guix show binutils@2.32
#+end_src

#+RESULTS:
#+begin_example
name: binutils
version: 2.32
outputs: out
systems: x86_64-linux i686-linux
dependencies: 
location: gnu/packages/base.scm:415:2
homepage: https://www.gnu.org/software/binutils/
license: GPL 3+
synopsis: Binary utilities: bfd gas gprof ld  
description: GNU Binutils is a collection of tools for working with binary
+ files.  Perhaps the most notable are "ld", a linker, and "as", an assembler.
+ Other tools include programs to display binary profiling information, list the
+ strings in a binary file, and utilities for working with archives.  The "bfd"
+ library for working with executable and object formats is also included.

#+end_example

#+begin_src sh :results output :exports both
exec 2>&1
guix show gcc@9.2.0
:
#+end_src

#+RESULTS:
: guix show: error: gcc@9.2.0: package not found

This looks a bit surprising. What's happening here is that =gcc= is defined as a /hidden package/ in Guix. The package is there, but it is hidden from package queries. There is a good reason for this: =gcc= on its own is rather useless, you need =gcc-toolchain= to actually use the compiler. But if both =gcc= and =gcc-toolchain= showed up in a search, that would be more confusing than helpful for most users. Hiding the package is a way of saying "reserved for experts".

Let's take this as a sign that it's time to move on to the next level of Guix hacking: Guile scripts. Guile, an implementation of the Scheme language, is Guix' native language, so using Guile scripts, you get access to everything there is to know about Guix and its packages. If you don't know Guile, don't worry: you should be able to follow without understanding the details of the code.

A note in passing: the [[https://emacs-guix.gitlab.io/website/][emacs-guix]] package provides an intermediate level of Guix exploration for Emacs users. It lets you look at hidden packages, for example. But much of what I will show in the following really requires Guile scripts.


* What's in a Guix package?

From the user's point of view, a package is a piece of software with a name and a version number that can be installed using =guix install=. From Guix' point of view, there is more to a package. Let's look at an example of a package definition: =xmag=. I have chosen this package not because I care much about it, but because its definition is short while showcasing all the features I want to explain. You can access it most easily by typing =guix edit xmag=. Here is what you will see:
#+begin_src scheme :eval no
(package
  (name "xmag")
  (version "1.0.6")
  (source
   (origin
     (method url-fetch)
     (uri (string-append
           "mirror://xorg/individual/app/" name "-" version ".tar.gz"))
     (sha256
      (base32
       "19bsg5ykal458d52v0rvdx49v54vwxwqg8q36fdcsv9p2j8yri87"))))
  (build-system gnu-build-system)
  (arguments
   `(#:configure-flags
     (list (string-append "--with-appdefaultdir="
                          %output ,%app-defaults-dir))))
  (inputs
   `(("libxaw" ,libxaw)))
  (native-inputs
   `(("pkg-config" ,pkg-config)))
  (home-page "https://www.x.org/wiki/")
  (synopsis "Display or capture a magnified part of a X11 screen")
  (description "Xmag displays and captures a magnified snapshot of a portion
of an X11 screen.")
  (license license:x11))
#+end_src
The package definition starts with the name and version information you expected. Next comes =source=, which says how to obtain the source code and from where. It also provides a hash that allows to check the integrity of the downloaded files. The next four items, =build-system=, =arguments=, =inputs=, and =native-inputs=, are what I am going to explain here. The rest is documentation for human consumption.. 

The following figure illustrates how the various pieces of information from a package are used in the build process (done by =guix build=, or implicitly when installing or otherwise using a package):
file:guix-package.svg

It may help to translate the Guix jargon to the vocabulary of C programming:
| Guix package | C program        |
|--------------+------------------|
| source code  | source code      |
| inputs       | libraries        |
| arguments    | compiler options |
| build system | compiler         |
| output       | executable       |

Building a package is in fact a generalization of compiling a program. We could in fact create a "GCC build system" for Guix that would simply run =gcc=, but such a build system would be of little practical use, since most real-life software consists of more than just one C source code file, and requires additional pre- or post-processing steps.

The example shown above has =native-inputs= in addition to "plain" =inputs=. There's actually a third variant, =propagated-inputs=, but =xmag= doesn't have ny. The differences between these variants don't matter for my topic, so I will just refer to "inputs" from now.

Guile uses a record type called =<package>= to represent packages, which is defined in module =(guix packages)=. There is also a module =(gnu packages)=, which contains the actual package definitions - be careful not to confuse the two (as I always do). Here is a simple Guile script that shows some package information, much like the =guix show= command that I used earlier:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)) 

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Name: ~a\n" (package-name gcc-toolchain))
(format #t "Version: ~a\n" (package-version gcc-toolchain))
(format #t "Inputs: ~a\n" (package-direct-inputs gcc-toolchain))
#+end_src

#+RESULTS:
: Name: gcc-toolchain
: Version: 9.2.0
: Inputs: ((gcc #<package gcc@9.2.0 gnu/packages/gcc.scm:524 7f50ed131b00>) (ld-wrapper #<package ld-wrapper@0 gnu/packages/base.scm:505 7f50ec340f20>) (binutils #<package binutils@2.32 gnu/packages/commencement.scm:2185 7f50ec338790>) (libc #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840>) (libc-debug #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840> debug) (libc-static #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840> static))

This script first calls =specification->package=  to look up the package using the same rules as the =guix= command line interface: pick the latest available version. Then it extracts various information about the package. Note that =package-direct-inputs= returns the combination of =package-inputs=, =package-native-inputs=, and =package-propagated-inputs=. As I said above, I don't care about the distinction here.

The inputs are not shown in a particularly nice form, so let's write two Guile functions to improve it:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    (other-item
     (format #f "~a" other-item))))

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Package: ~a\n"
        (package->specification gcc-toolchain))
(format #t "Inputs: ~a\n"
        (map input->specification (package-direct-inputs gcc-toolchain)))
#+end_src

#+RESULTS:
: Package: gcc-toolchain@9.2.0
: Inputs: (gcc@9.2.0 ld-wrapper@0 binutils@2.32 glibc@2.29 glibc@2.29 glibc@2.29)

That looks much better. As you can see from the code, a list of inputs is a bit more than a list of packages, as each input also has a label and possibly more - but all we care about here is the package. That also explains why we see =glibc= three times in the input list: the "possibly more" information is different for each of them. As a final cleanup step, let's show a list of unique inputs:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (srfi srfi-1)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    (other-item
     (format #f "~a" other-item))))

(define (unique-inputs inputs)
  (delete-duplicates
   (map input->specification inputs)))

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Package: ~a\n"
        (package->specification gcc-toolchain))
(format #t "Inputs: ~a\n"
        (unique-inputs (package-direct-inputs gcc-toolchain)))
#+end_src

#+RESULTS:
: Package: gcc-toolchain@9.2.0
: Inputs: (gcc@9.2.0 ld-wrapper@0 binutils@2.32 glibc@2.29)
