#+TITLE: Computational reproducibility with Guix

* Dependencies: what it takes to run a program
Let's start with a simple (and rather uninteresting) C program:
#+begin_src c :tangle pi.c :eval no
#include <math.h>
#include <stdio.h>

int main()
{
    printf( "M_PI: %.10lf\n", M_PI);
    printf( "4 * atan(1.): %.10lf\n", 4.*atan(1.));
    printf( "Leibniz' formula (four terms): %.10lf\n", 4.*(1.-1./3.+1./5.-1./7.));
    return 0;
}
#+end_src

What does it take to actually run this program? A C compiler, obviously. Let's create an environment containing nothing but a C compiler. The option =--container= ensures the best possible isolation from the standard environment that your system installation and user account provide for day-to-day work. This environment really contains nothing but a C compiler, and has access to no other files than those in the current directory.

#+begin_src sh :session C-compiler :results output :exports both
guix environment --container --ad-hoc gcc-toolchain
#+end_src

#+RESULTS:

Now I can compile and run my little program:
#+begin_src sh :session C-compiler :results output :exports both
gcc pi.c -o pi
./pi
#+end_src

#+RESULTS:
: 
: pi = 3.1415926536
: 4 * atan(1.): 3.1415926536
: Leibniz' formula (four terms): 2.8952380952

It works! So now I can be sure that my program has a single dependency: the Guix package =gcc-toolchain=. The "toolchain" part suggests that it contains a bit more than just the compiler. Let's look at it in more detail:

#+begin_src sh :results output :exports both
guix show gcc-toolchain
#+end_src

#+RESULTS:
#+begin_example
name: gcc-toolchain
version: 9.2.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@9.2.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 8.3.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@8.3.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 7.4.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@7.4.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 6.5.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@6.5.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 5.5.0
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@5.5.0 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 4.9.4
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@4.9.4 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

name: gcc-toolchain
version: 4.8.5
outputs: out debug static
systems: x86_64-linux i686-linux
dependencies: binutils@2.32 gcc@4.8.5 glibc@2.29 ld-wrapper@0
location: gnu/packages/commencement.scm:2532:4
homepage: https://gcc.gnu.org/
license: GPL 3+
synopsis: Complete GCC tool chain for C/C++ development  
description: This package provides a complete GCC tool chain for C/C++
+ development to be installed in user profiles.  This includes GCC, as well as
+ libc (headers an d binaries, plus debugging symbols in the `debug' output),
+ and Binutils.

#+end_example

Guix actually knows about several versions of this toolchain. We didn't ask for a specific one, so what we got is the first one in this list, which is the one with the highest version number. Let's check:
#+begin_src sh :session C-compiler :results output :exports both
gcc --version
#+end_src

#+RESULTS:
: gcc (GCC) 9.2.0
: Copyright (C) 2019 Free Software Foundation, Inc.
: This is free software; see the source for copying conditions.  There is NO
: warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

The dependency list of =gcc-toolchain@9.2.0= is among the information provided by =guix show= (see output above):
#+begin_example
binutils@2.32 gcc@9.2.0 glibc@2.29 ld-wrapper@0
#+end_example

Now we can feed these dependencies to =guix show=, one by one, in order to learn more about them:
#+begin_src sh :results output :exports both
guix show binutils@2.32
#+end_src

#+RESULTS:
#+begin_example
name: binutils
version: 2.32
outputs: out
systems: x86_64-linux i686-linux
dependencies: 
location: gnu/packages/base.scm:415:2
homepage: https://www.gnu.org/software/binutils/
license: GPL 3+
synopsis: Binary utilities: bfd gas gprof ld  
description: GNU Binutils is a collection of tools for working with binary
+ files.  Perhaps the most notable are "ld", a linker, and "as", an assembler.
+ Other tools include programs to display binary profiling information, list the
+ strings in a binary file, and utilities for working with archives.  The "bfd"
+ library for working with executable and object formats is also included.

#+end_example

#+begin_src sh :results output :exports both
exec 2>&1
guix show gcc@9.2.0
:
#+end_src

#+RESULTS:
: guix show: error: gcc@9.2.0: package not found

This looks a bit surprising. What's happening here is that =gcc= is defined as a /hidden package/ in Guix. The package is there, but it is hidden from package queries. There is a good reason for this: =gcc= on its own is rather useless, you need =gcc-toolchain= to actually use the compiler. But if both =gcc= and =gcc-toolchain= showed up in a search, that would be more confusing than helpful for most users. Hiding the package is a way of saying "experts only".

Let's take this as a sign that it's time to move on to the next level of Guix hacking: Guile scripts. Guile, an implementation of the Scheme language, is Guix' native language, so using Guile scripts, you get access to everything there is to know about Guix and its packages. If you don't know Guile, don't worry: you should be able to follow without understanding the details of the code.

A note in passing: the [[https://emacs-guix.gitlab.io/website/][emacs-guix]] package provides an intermediate level of Guix exploration for Emacs users. It lets you look at hidden packages, for example. But much of what I will show in the following really requires Guile scripts.

* Anatomy of a Guix package

From the user's point of view, a package is a piece of software with a name and a version number that can be installed using =guix install=. The packager's point of view is quite a bit different. In fact, what users consider a package is more precisely called the package's /output/ in Guix jargon. The full package is a recipe for creating this output.

To see how all these concepts fit together, let's look at an example of a package definition: =xmag=. I have chosen this package not because I care much about it, but because its definition is short while showcasing all the features I want to explain. You can access it most easily by typing =guix edit xmag=. Here is what you will see:
#+begin_src scheme :eval no
(package
  (name "xmag")
  (version "1.0.6")
  (source
   (origin
     (method url-fetch)
     (uri (string-append
           "mirror://xorg/individual/app/" name "-" version ".tar.gz"))
     (sha256
      (base32
       "19bsg5ykal458d52v0rvdx49v54vwxwqg8q36fdcsv9p2j8yri87"))))
  (build-system gnu-build-system)
  (arguments
   `(#:configure-flags
     (list (string-append "--with-appdefaultdir="
                          %output ,%app-defaults-dir))))
  (inputs
   `(("libxaw" ,libxaw)))
  (native-inputs
   `(("pkg-config" ,pkg-config)))
  (home-page "https://www.x.org/wiki/")
  (synopsis "Display or capture a magnified part of a X11 screen")
  (description "Xmag displays and captures a magnified snapshot of a portion
of an X11 screen.")
  (license license:x11))
#+end_src
The package definition starts with the name and version information you expected. Next comes =source=, which says how to obtain the source code and from where. It also provides a hash that allows to check the integrity of the downloaded files. The next four items, =build-system=, =arguments=, =inputs=, and =native-inputs= supply the information required for /building/ the package. That's what matters for reproducibility, so that's what I will focus on. The remaining items are documentation for human consumption, important for other reasons but not for reproducibility. 

The example package definition has =native-inputs= in addition to "plain" =inputs=. There's actually a third variant, =propagated-inputs=, but =xmag= doesn't have any. The differences between these variants don't matter for my topic, so I will just refer to "inputs" from now on. Another omission I will make is the possibility to define several outputs for a package. This is done for particularly big packages, in order to reduce the footprint of installations, but for the purposes of reproducibility, it's OK to treat all outputs of a package a s single unit.

The following figure illustrates how the various pieces of information from a package are used in the build process (done by =guix build=, or implicitly when installing or otherwise using a package):
file:guix-package.svg

It may help to translate the Guix jargon to the vocabulary of C programming:
| Guix package | C program        |
|--------------+------------------|
| source code  | source code      |
| inputs       | libraries        |
| arguments    | compiler options |
| build system | compiler         |
| output       | executable       |

Building a package can be considered a generalization of compiling a program. We could in fact create a "GCC build system" for Guix that would simply run =gcc=, but such a build system would be of little practical use, since most real-life software consists of more than just one C source code file, and requires additional pre- or post-processing steps.

* Package exploration in Guile

Guile uses a record type called =<package>= to represent packages, which is defined in module =(guix packages)=. There is also a module =(gnu packages)=, which contains the actual package definitions - be careful not to confuse the two (as I always do). Here is a simple Guile script that shows some package information, much like the =guix show= command that I used earlier:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)) 

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Name: ~a\n" (package-name gcc-toolchain))
(format #t "Version: ~a\n" (package-version gcc-toolchain))
(format #t "Inputs: ~a\n" (package-direct-inputs gcc-toolchain))
#+end_src

#+RESULTS:
: Name: gcc-toolchain
: Version: 9.2.0
: Inputs: ((gcc #<package gcc@9.2.0 gnu/packages/gcc.scm:524 7f50ed131b00>) (ld-wrapper #<package ld-wrapper@0 gnu/packages/base.scm:505 7f50ec340f20>) (binutils #<package binutils@2.32 gnu/packages/commencement.scm:2185 7f50ec338790>) (libc #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840>) (libc-debug #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840> debug) (libc-static #<package glibc@2.29 gnu/packages/commencement.scm:2143 7f50ec338840> static))

This script first calls =specification->package=  to look up the package using the same rules as the =guix= command line interface: pick the latest available version. Then it extracts various information about the package. Note that =package-direct-inputs= returns the combination of =package-inputs=, =package-native-inputs=, and =package-propagated-inputs=. As I said above, I don't care about the distinction here.

The inputs are not shown in a particularly nice form, so let's write two Guile functions to improve it:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    (other-item
     (format #f "~a" other-item))))

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Package: ~a\n"
        (package->specification gcc-toolchain))
(format #t "Inputs: ~a\n"
        (map input->specification (package-direct-inputs gcc-toolchain)))
#+end_src

#+RESULTS:
: Package: gcc-toolchain@9.2.0
: Inputs: (gcc@9.2.0 ld-wrapper@0 binutils@2.32 glibc@2.29 glibc@2.29 glibc@2.29)

That looks much better. As you can see from the code, a list of inputs is a bit more than a list of packages. It is in fact a list of labelled /outputs/ of packages. That also explains why we see =glibc= three times in the input list: =glibc= defines three distinct outputs. For reproducibility, all we care about is the package references. Later on in this post, we will deal with much longer input lists, so as a final cleanup step, let's show only unique package references from the list of inputs:
#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (srfi srfi-1)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    (other-item
     (format #f "~a" other-item))))

(define (unique-inputs inputs)
  (delete-duplicates
   (map input->specification inputs)))

(define gcc-toolchain
  (specification->package "gcc-toolchain"))

(format #t "Package: ~a\n"
        (package->specification gcc-toolchain))
(format #t "Inputs: ~a\n"
        (unique-inputs (package-direct-inputs gcc-toolchain)))
#+end_src

#+RESULTS:
: Package: gcc-toolchain@9.2.0
: Inputs: (gcc@9.2.0 ld-wrapper@0 binutils@2.32 glibc@2.29)

* Dependencies

You may have noticed the absence of the term "dependency" from the last two sections. There is a good reason for that: the term is used in somewhat different meanings, and that can create confusion.

The figure above shows three kinds of input to the build system: source, inputs, and arguments. These categories reflect the packagers' point of view: "source" is what the authors of the software supply, "inputs" are other packages, written by different people, and "arguments" is what the packagers themselves add to the build procedure. It is important to understand that from a purely technical point of view, there is no fundamental difference between the three categories. You could, for example, define a package that contains C source code in the build system arguments, but leaves "source" empty. This would be inconvenient, and confusing for others, so I don't recommend you actually do this. The three categories are important, but for humans, not for computers. In fact, even the build system is not fundamentally distinct from its inputs. You could define a special-purpose build system for one package, and put all the source code in there. At the level of the CPU and the computer's memory, a build process (as in fact /any/ computation) looks like
file:computation.png
It is human interpretation that decomposes this into
file:data-code.png
and in a next step into
file:data-program-environment.png
We can go on and divide the "environment" into "operating system", "development tools", and "application software", for example, but the further we go in decomposing the input to a computation, the more arbitrary it gets.

From this point of view, a software's dependencies consist of all the inputs required to run it, in addition to its source code. For a Guix package, the dependencies are thus
- its inputs
- the build system arguments
- the build system itself
- Guix
- the GNU/Linux operating system

In the following, I will not mention the last two items any more, because they are a common dependency of all Guix packages, but it's important not to forget about them. A change in Guix or in GNU/Linux can actually make a computation non-reproducible, although in practice that happens very rarely.

* Build systems are packages as well

I hope that by now you have a good idea of what a package is: a recipe for building outputs from source and inputs, with inputs being the outputs of other packages. The recipe involves a build system and arguments supplied to it. So... what exactly is a build system? I have introduced it as a generalization of a compiler, which describes its role. But where does a build system come from in Guix?

The ultimate answer is of course the source code. Build systems are pieces of Guile code that are part of Guix. But this Guile code is only a shallow layer orchestrating invocations of other software, such as =gcc= or =make=. And that software is defined by packages. So in the end, from a reproducibility point of view, we can replace the "build system" item in our list of dependenies by "a bundle of packages". In other words: more inputs,

Before Guix can build a package, it must gather all the required ingredients, and that includes replacing the build system by the packages it represents. The resulting list of ingredients is called a =bag=, and we can access it using a Guile script:

#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (srfi srfi-1)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    ((label (? origin? origin))
     (format #f "[source code from ~a]"
             (origin-uri origin)))
    (other-input
     (format #f "~a" other-input))))

(define (unique-inputs inputs)
  (delete-duplicates
   (map input->specification inputs)))

(define hello
  (specification->package "hello"))

(format #t "Package: ~a\n"
        (package->specification hello))
(format #t "Package inputs: ~a\n"
        (unique-inputs (package-direct-inputs hello)))
(format #t "Build inputs: ~a\n"
        (unique-inputs
         (bag-direct-inputs
          (package->bag hello))))
#+end_src

#+RESULTS:
: Package: hello@2.10
: Package inputs: ()
: Build inputs: ([source code from mirror://gnu/hello/hello-2.10.tar.gz] tar@1.32 gzip@1.10 bzip2@1.0.6 xz@5.2.4 file@5.33 diffutils@3.7 patch@2.7.6 findutils@4.6.0 gawk@5.0.1 sed@4.7 grep@3.3 coreutils@8.31 make@4.2.1 bash-minimal@5.0.7 ld-wrapper@0 binutils@2.32 gcc@7.4.0 glibc@2.29 glibc-utf8-locales@2.29)

I have used a different example, =binutils=, because for =gcc-toolchain=, there is no difference between package inputs and build inputs (check for yourself if you want!) My new example, =hello= (a short demo program printing "Hello, world" in the language of the system installation), is interesting because it has no package inputs at all. All the build inputs except for the source code have thus been contributed by the build system.

If you compare this script to the previous one that printed only the package inputs, you will notice two major new features. In =input->specification=, there is an additional case for the source code reference. And in the last statement, =package->bag= constructs a bag from the package, before =bag-direct-inputs= is called to get the input list.

* Inputs are outputs

I have mentioned before that one package's inputs are other packages' outputs, but that fact deserves a more in-depth discussion because of its crucial importance for reproducibility. A package is a recipe for building outputs from source and inputs. Since these inputs are outputs, they must have been built as well. Package building is therefore a process consisting of multiple steps. An immediate consequence is that any computation making use of packaged software is a multi-step computation as well.

Remember the short C program computing π from the beginning of this post? Running that program is only the last step in a long series of computations. Before you can run =pi=, you must compile =pi.c=. That requires the package =gcc-toolchain=, which must first be built. And before it can be built, its inputs must be built. And so on. If you want the output of =pi= to be reproducible, *the whole chain of computations must be reproducible*, because each step can have an impact on the results produced by =pi=.

So... where this chain start? Nobody writes machine code any more these days, so all software requires some compiler or interpreter. And that means that for every package, there are other packages that must be built first. This is known as the bootstrapping problem. A rough summary of the solution is that the chain starts on somebody else's computer, which creates a bootstrap seed, an ideally small package that is downloaded in precompiled form. See [[https://guix.gnu.org/blog/2019/guix-reduces-bootstrap-seed-by-50/][this post by Jan Nieuwenhuizen]] for details of this procedure. The bootstrap seed is not the real start of the chain, but as long as we can retrieve an identical copy at a later time, that's good enough for reproducibility.

Now we are finally ready for the ultimate step in dependency analysis: identifying all packages on which a computation depends, right up to the bootstrap seed. The starting point is the list of direct inputs of the bag derived from a package, which we looked at in the previous script. For each package in that list, we must apply this same procedure, recursively. The function =package-closure= in Guix does exactly the, and if you have some basic knowledge of Scheme, you should be able to understand its implementation now. 

#+begin_src scheme :results output
(use-modules (guix packages)
             (gnu packages)
             (srfi srfi-1)
             (ice-9 match))

(define (package->specification package)
  (format #f "~a@~a"
          (package-name package)
          (package-version package)))

(define (input->specification input)
  (match input
    ((label (? package? package) . _)
     (package->specification package))
    ((label (? origin? origin))
     (format #f "[source code from ~a]"
             (origin-uri origin)))
    (other-input
     (format #f "~a" other-input))))

(define (unique-inputs inputs)
  (delete-duplicates
   (map input->specification inputs)))

(define hello
  (specification->package "hello"))

(format #t "Package: ~a\n"
        (package->specification hello))
(format #t "Package inputs: ~a\n"
        (unique-inputs (package-direct-inputs hello)))
(format #t "Build inputs: ~a\n"
        (unique-inputs
         (bag-direct-inputs
          (package->bag hello))))
(format #t "Package closure: ~a\n"
        (delete-duplicates
         (map package->specification
              (package-closure (list hello)))))
#+end_src

#+RESULTS:
: Package: hello@2.10
: Package inputs: ()
: Build inputs: ([source code from mirror://gnu/hello/hello-2.10.tar.gz] tar@1.32 gzip@1.10 bzip2@1.0.6 xz@5.2.4 file@5.33 diffutils@3.7 patch@2.7.6 findutils@4.6.0 gawk@5.0.1 sed@4.7 grep@3.3 coreutils@8.31 make@4.2.1 bash-minimal@5.0.7 ld-wrapper@0 binutils@2.32 gcc@7.4.0 glibc@2.29 glibc-utf8-locales@2.29)
: Package closure: (m4@1.4.18 libatomic-ops@7.6.10 gmp@6.1.2 libgc@7.6.12 libltdl@2.4.6 libunistring@0.9.10 libffi@3.2.1 pkg-config@0.29.2 guile@2.2.6 libsigsegv@2.12 lzip@1.21 ed@1.15 perl@5.30.0 guile-bootstrap@2.0 zlib@1.2.11 xz@5.2.4 ncurses@6.1-20190609 libxml2@2.9.9 attr@2.4.48 gettext-minimal@0.20.1 gcc-cross-boot0-wrapped@7.4.0 libstdc++@7.4.0 ld-wrapper-boot3@0 bootstrap-binaries@0 ld-wrapper-boot0@0 flex@2.6.4 glibc-intermediate@2.29 libstdc++-boot0@4.9.4 expat@2.2.7 gcc-mesboot1-wrapper@4.7.4 mesboot-headers@0.19 gcc-core-mesboot@2.95.3 bootstrap-mes@0 bootstrap-mescc-tools@0.5.2 tcc-boot0@0.9.26-6.c004e9a mes-boot@0.19 tcc-boot@0.9.27 make-mesboot0@3.80 gcc-mesboot0@2.95.3 binutils-mesboot0@2.20.1a make-mesboot@3.82 diffutils-mesboot@2.7 gcc-mesboot1@4.7.4 glibc-headers-mesboot@2.16.0 glibc-mesboot0@2.2.5 binutils-mesboot@2.20.1a linux-libre-headers@4.19.56 linux-libre-headers-bootstrap@0 gcc-mesboot@4.9.4 glibc-mesboot@2.16.0 gcc-cross-boot0@7.4.0 bash-static@5.0.7 gettext-boot0@0.19.8.1 python-minimal@3.5.7 perl-boot0@5.30.0 texinfo@6.6 bison@3.4.1 gzip@1.10 libcap@2.27 acl@2.2.53 glibc-utf8-locales@2.29 gcc-mesboot-wrapper@4.9.4 file-boot0@5.33 findutils-boot0@4.6.0 diffutils-boot0@3.7 make-boot0@4.2.1 binutils-cross-boot0@2.32 glibc@2.29 gcc@7.4.0 binutils@2.32 ld-wrapper@0 bash-minimal@5.0.7 make@4.2.1 coreutils@8.31 grep@3.3 sed@4.7 gawk@5.0.1 findutils@4.6.0 patch@2.7.6 diffutils@3.7 file@5.33 bzip2@1.0.6 tar@1.32 hello@2.10)

That's 84 packages, just for printing "Hello, world!". As promised, it includes the boostrap seed, called =bootstrap-binaires=. It may be more surprising to see Perl and Python in the dependency list of what is a pure C program. The explanation is that the build process of =gcc= and =glibc= contains Perl and Python code.

